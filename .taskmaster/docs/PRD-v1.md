<!-- # path: PRD.md -->

# Overview

A standalone web application for inspecting and analyzing Codex CLI session recordings. The product parses `.jsonl` session files generated by Codex CLI and provides an interface to review conversation history, code changes, and tool executions without the Codex runtime. Target users: developers, reviewers, and teams who need to audit or study agentic coding sessions. Value: local-first analysis, fast navigation, exportable artifacts, and independence from the Codex stack.

## Core Features

### Session Management

- **What:** Open `.jsonl` via file picker or drag-and-drop; maintain a session library; display metadata.
- **Why:** Quick access and recall of important sessions.
- **How:** Browser File API or desktop wrapper; local IndexedDB for library.

### Timeline Visualization

- **What:** Chronological event stream, filters, full-text search, bookmarks.
- **Why:** Accelerates understanding of session flow.
- **How:** Virtualized list; filter pipeline; in-memory search index.

### Code Analysis

- **What:** Diff viewer (unified/split), file tree, patch tracking, command history.
- **Why:** Clarifies code evolution and shell activity.
- **How:** Monaco diff; derived file-change graph; command/output panels.

### Export & Sharing

- **What:** Export filtered events as JSON/Markdown/HTML; extract artifacts; generate permalinks.
- **Why:** Reporting and collaboration.
- **How:** Client-side transforms; blob downloads; optional hash-based deep links.

## User Experience

### Personas

- **Individual Developer:** Reviews own sessions to learn and refactor.
- **Code Reviewer:** Audits decisions and changes across a session.
- **Team Lead / Researcher:** Aggregates insights across many sessions.

### Key User Flows

1. **Open Session:** Launch app → Drop `.jsonl` → See metadata and timeline.
2. **Investigate Change:** Filter by file/tool → Jump to diffs → Inspect command outputs.
3. **Create Report:** Bookmark key events → Export Markdown summary → Share.
4. **Artifact Extraction:** Locate generated files → Download bundle.

### UI/UX Considerations

- Keyboard navigation across timeline, files, and bookmarks.
- Large-file responsiveness via virtualization and streaming parse.
- Accessible contrasts and semantic regions; diff color-blind safe markers.
- Deep-linkable event selection and preserved filter state in URL.

## Technical Architecture

### Data Layer (TypeScript)

```typescript
interface SessionMeta {
  id: string;
  timestamp: string;
  instructions?: string;
  git?: GitInfo;
}

type ResponseItem =
  | { type: 'Message' | 'FunctionCall' | 'LocalShellCall' | 'Reasoning' | 'WebSearchCall' | 'Other' } & Record<string, unknown>;

interface FileChange {
  path: string;
  diff?: string;
  patches?: string[];
}
interface Artifact {
  name: string;
  path?: string;
  contentType?: string;
  bytes?: Uint8Array;
}
interface ParsedSession {
  meta: SessionMeta;
  events: ResponseItem[];
  fileChanges: FileChange[];
  artifacts: Artifact[];
}
```

### Frontend Stack

- React 18 + TypeScript, Vite, Zustand, Tailwind + Headless UI, Monaco Editor, React Window.

### Backend Options

- **Client-only:** Pure web app using File API.
- **Desktop:** Electron wrapper for richer FS access.
- **Web service (optional):** Team sharing deployment.

### File Processing

- JSONL streaming parser, schema validation of variants, error recovery, incremental loading.

## Development Roadmap

### Phase 1: Core Viewer (MVP)

- JSONL parse and validate
- Timeline with event cards
- Metadata panel
- Basic search
- File tree
- Basic diff viewer

### Phase 2: Enhanced Analysis

- Advanced filters and search
- Syntax highlighting
- Command timeline
- Export JSON/Markdown
- Bookmarks
- Responsive layout

### Phase 3: Advanced Features

- Multi-session comparison
- Analytics and metrics
- Plugin system for custom event types
- Team collaboration options
- External tool integrations
- Large-file performance optimizations

## Logical Dependency Chain

1. **Foundations:** JSONL parser → schema guardrails → virtualized timeline.
2. **Usable UI quickly:** Metadata + basic search + file tree + basic diffs.
3. **Depth features:** Filters, bookmarks, command timeline, syntax highlight.
4. **Outputs:** Exporters and artifact extraction.
5. **Scale and polish:** Performance, analytics, plugins, collaboration.

## Risks and Mitigations

- **Schema drift:** Versioned parsers, graceful fallback to raw JSON, update notices.
- **Large files:** Streaming parse, virtualization, worker-based parsing.
- **Security/privacy:** Local-first default, no external requests, strict content sanitization.
- **Scope creep:** Phased roadmap and dependency chain to protect MVP.

## Appendix

## Data Format Compatibility

**Directory layout:**

```txt
.codex/sessions/YYYY/MM/DD/rollout-{timestamp}-{uuid}.jsonl
```

**JSONL expectations:**

- Line 1: `SessionMeta`
- Lines 2+: `ResponseItem` events

**Supported ResponseItem types:** Message, Reasoning, FunctionCall, LocalShellCall, WebSearchCall, CustomToolCall, Other.

## Success Metrics

- Parse success rate ≥ 99%
- 10MB file parse < 2s on modern hardware
- Interaction latency < 100ms
- Memory footprint ≤ 500MB on large sessions
- Feature usage: search, diff, export, bookmarks

## Distribution Strategy

- **Static Web App:** Vercel/Netlify
- **Desktop App:** Electron
- **Browser Extension:** Chrome/Firefox
- **Docker:** Self-hosted

## Non-Goals (Initial)

- Live session following
- Editing sessions
- Coupling to Codex runtime
- ML-based insights
- Multi-user real-time collaboration

## Key Differences vs Codex-Integrated

- Independence from Rust infrastructure
- Modern web-first UI stack
- Backward compatibility across session formats
- Simple deployment paths

## Citations and References

- Representative mappings of response events to UI views align with typical Codex protocol variants (message, reasoning, web search, function/shell calls).
- Rust excerpts and prior wiki notes were used to inform event categorization and `SessionMeta` shape; exact upstream paths may vary by version.
