{
  "master": {
    "tasks": [
      {
        "id": 29,
        "title": "Initialize Project Foundation",
        "description": "Set up the initial project structure using the specified frontend stack: React 18, TypeScript, Vite, Zustand, and Tailwind CSS with Headless UI.",
        "details": "Create a new Vite project with the React+TS template. Install and configure Tailwind CSS, Headless UI, and Zustand for state management. Establish a basic file structure for components, services, and data models.",
        "testStrategy": "Verify that the development server runs successfully and that a basic 'Hello World' component renders with Tailwind styles applied.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Define Core Data Models in TypeScript",
        "description": "Implement the TypeScript interfaces for the application's data layer, including SessionMeta, ResponseItem, FileChange, and ParsedSession.",
        "details": "Create a `types.ts` or similar file to define the interfaces as specified in the PRD's 'Data Layer' section. Ensure types are exported for use across the application.",
        "testStrategy": "Code review to ensure type definitions match the PRD. TypeScript compiler should pass without errors when these types are imported and used.",
        "priority": "high",
        "dependencies": [
          29
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Implement Streaming JSONL Parser",
        "description": "Develop a robust parser for `.jsonl` session files that can handle large files by streaming and processing them line by line.",
        "details": "The parser should read a File object, process it incrementally, and parse each line as a JSON object. The first line is `SessionMeta`, and subsequent lines are `ResponseItem` events. Implement basic error recovery for malformed JSON lines.",
        "testStrategy": "Unit test the parser with valid, large, and malformed `.jsonl` files. Test performance to meet the '< 2s for 10MB file' metric.",
        "priority": "high",
        "dependencies": [
          30
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Implement Session Loading via File Picker",
        "description": "Create a UI component that allows users to open a `.jsonl` file using the browser's native file picker.",
        "details": "Use the Browser File API (`<input type='file'>`) to let users select a file. On selection, pass the file to the JSONL parser and update the application state with the parsed session data.",
        "testStrategy": "Manual test: Click a button, select a valid `.jsonl` file, and verify that the session data is loaded into the application's state.",
        "priority": "high",
        "dependencies": [
          31
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Implement Session Loading via Drag-and-Drop",
        "description": "Add a drag-and-drop zone to the main application window for opening `.jsonl` files.",
        "details": "Implement event listeners for `dragover`, `dragleave`, and `drop` events. On drop, access the file from the `DataTransfer` object and process it with the JSONL parser.",
        "testStrategy": "Manual test: Drag a `.jsonl` file from the desktop onto the application window and verify the session loads correctly.",
        "priority": "high",
        "dependencies": [
          31
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Create Session Metadata Display Panel",
        "description": "Build a React component to display the parsed session metadata, such as timestamp, instructions, and git info.",
        "details": "The component will receive the `SessionMeta` object as a prop and render its contents in a clear, readable format. This will be part of the main session view.",
        "testStrategy": "Component test: Pass a mock `SessionMeta` object and verify all fields are displayed correctly. Manual test: Load a session and check the panel.",
        "priority": "high",
        "dependencies": [
          32
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Build Virtualized Timeline for Events",
        "description": "Implement the main chronological event stream using a virtualized list to ensure performance with a large number of events.",
        "details": "Use a library like `react-window` to render only the visible event items. The list will be fed the `events` array from the `ParsedSession` object.",
        "testStrategy": "Test with a session containing thousands of events to confirm smooth scrolling and low memory usage. Interaction latency should be < 100ms.",
        "priority": "high",
        "dependencies": [
          31
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Develop Basic Event Card Component",
        "description": "Create a generic React component to render a single event within the timeline. It should display the event type and a summary of its content.",
        "details": "The component will take a `ResponseItem` as a prop and use a switch statement or mapping to render different content based on the event `type` (e.g., 'Message', 'FunctionCall').",
        "testStrategy": "Component tests for each supported event type to ensure correct rendering. Visual regression testing can be beneficial here.",
        "priority": "high",
        "dependencies": [
          30
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Implement Basic Full-Text Search",
        "description": "Add a search input that allows users to perform a case-insensitive text search across all events in the timeline.",
        "details": "Create an in-memory search index or filter the `events` array based on the search query. Highlight matching text in the event cards and provide a way to navigate between results.",
        "testStrategy": "Manual test: Load a session, type a query, and verify that the timeline filters to show only matching events and that text is highlighted.",
        "priority": "high",
        "dependencies": [
          35
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "Create File Tree Component",
        "description": "Build a component that displays a tree view of all files that were modified during the session.",
        "details": "Derive the file structure from the `fileChanges` array in the `ParsedSession` object. Clicking a file should trigger an action to show its diff.",
        "testStrategy": "Component test with a mock `fileChanges` array. Manual test: Load a session with file changes and verify the tree is accurate.",
        "priority": "high",
        "dependencies": [
          31
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "Integrate Basic Diff Viewer",
        "description": "Integrate the Monaco Editor to display diffs for file changes. Initially, support a unified diff view.",
        "details": "Use the `monaco-diff-editor` component. When a user selects a file from the file tree, feed the corresponding `diff` string from the `FileChange` object to the editor.",
        "testStrategy": "Manual test: Click a file in the file tree and verify that the correct diff is displayed in the Monaco editor instance.",
        "priority": "high",
        "dependencies": [
          38
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "Implement Advanced Timeline Filters",
        "description": "Enhance the timeline with controls to filter events by type (Message, FunctionCall, etc.), text content, and associated file paths.",
        "details": "Build a filter pipeline that can be controlled by a set of UI components (checkboxes, text inputs). The virtualized list should update instantly as filters are applied.",
        "testStrategy": "Manual test: Apply various filter combinations and verify the timeline updates correctly and performs well.",
        "priority": "medium",
        "dependencies": [
          35,
          37
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 41,
        "title": "Add Syntax Highlighting to Diff Viewer",
        "description": "Configure the Monaco diff editor to apply syntax highlighting based on the language of the file being viewed.",
        "details": "Detect the file extension from the `path` in the `FileChange` object and set the `language` property on the Monaco editor instance accordingly.",
        "testStrategy": "Manual test: View diffs for various file types (e.g., `.js`, `.py`, `.rs`, `.md`) and confirm that syntax highlighting is applied correctly.",
        "priority": "medium",
        "dependencies": [
          39
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 42,
        "title": "Create Command History Timeline",
        "description": "Implement a dedicated view or filter that isolates `LocalShellCall` events to show a clear history of commands and their outputs.",
        "details": "This could be a special filter on the main timeline or a separate panel. It should clearly pair each command with its corresponding standard output and error streams.",
        "testStrategy": "Manual test: Load a session with shell commands and activate the command view. Verify that all commands and their outputs are displayed chronologically and are easy to read.",
        "priority": "medium",
        "dependencies": [
          40
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 43,
        "title": "Implement Event Bookmarking",
        "description": "Allow users to bookmark or 'star' important events in the timeline for quick reference and for use in exports.",
        "details": "Add a bookmark icon to each event card. Manage a list of bookmarked event IDs in the application state. Provide a way to view only bookmarked events.",
        "testStrategy": "Manual test: Bookmark several events, apply a 'show bookmarked only' filter, and verify the correct events are shown. Ensure bookmarks persist during the session.",
        "priority": "medium",
        "dependencies": [
          35
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 44,
        "title": "Implement Export to JSON",
        "description": "Create a function to export the current view of events (all, filtered, or bookmarked) as a JSON file.",
        "details": "The function will collect the relevant `ResponseItem` objects, serialize them to a JSON string, create a Blob, and trigger a client-side download.",
        "testStrategy": "Manual test: Filter the timeline, click 'Export to JSON', and verify the downloaded file contains only the filtered events.",
        "priority": "medium",
        "dependencies": [
          40,
          43
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 45,
        "title": "Implement Export to Markdown",
        "description": "Create a function to export a summary of the session, or a selection of events, into a Markdown file.",
        "details": "Transform the selected `ResponseItem` objects into a human-readable Markdown format. For example, format `Message` events as blockquotes and `LocalShellCall` events as code blocks. Trigger a client-side download.",
        "testStrategy": "Manual test: Bookmark a few key events, export as Markdown, and open the file to verify its formatting and content.",
        "priority": "medium",
        "dependencies": [
          40,
          43
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 46,
        "title": "Ensure Responsive UI Layout",
        "description": "Refine the application's layout to be responsive and usable across different screen sizes, from mobile to large desktops.",
        "details": "Use Tailwind's responsive modifiers (e.g., `md:`, `lg:`) to adjust flex layouts, panel visibility, and font sizes. Test common breakpoints.",
        "testStrategy": "Manual test: Resize the browser window or use browser developer tools to simulate different devices. Verify the layout adapts gracefully without breaking.",
        "priority": "medium",
        "dependencies": [
          34,
          35,
          38
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 47,
        "title": "Implement Deep Linking and URL State",
        "description": "Preserve the application state (like selected event, filter settings) in the URL hash to allow for sharing specific views.",
        "details": "Use a library or custom hook to serialize the relevant state to the URL hash. On page load, parse the hash to restore the application state. This enables permalinks.",
        "testStrategy": "Manual test: Apply a filter, select an event, copy the URL. Open the URL in a new tab and verify the application loads in the exact same state.",
        "priority": "medium",
        "dependencies": [
          40
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 48,
        "title": "Implement Session Library with IndexedDB",
        "description": "Maintain a library of previously opened sessions for quick access, storing metadata in the browser's IndexedDB.",
        "details": "When a session is opened, store its `SessionMeta` and a reference to its location (if possible, or just its name) in an IndexedDB table. Create a UI to list and reopen these sessions.",
        "testStrategy": "Manual test: Open several sessions. Close and reopen the app. Verify the sessions are listed in the library and can be re-accessed.",
        "priority": "medium",
        "dependencies": [
          32,
          33
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define IndexedDB Schema and Create DB Service",
            "description": "Create a dedicated service for IndexedDB operations. Define the database schema, including the object store, keys, and indexes for storing session metadata.",
            "dependencies": [],
            "details": "Create a new file `src/lib/session-db.ts`. Use the `idb` library (if available, otherwise plain IndexedDB) to set up a database named `codex-session-viewer`. Create an object store named `sessions`. The key path should be the session ID from `SessionMeta`. Define an index on `lastOpened` for sorting. The stored object type, `SessionLibraryEntry`, should be defined in `src/types/session.ts` and include the session `id`, `fileName`, `lastOpened` (timestamp), the full `SessionMeta` object, and an optional `fileHandle` for re-opening.",
            "status": "pending",
            "testStrategy": "Verify the database and object store are created correctly in the browser's developer tools."
          },
          {
            "id": 2,
            "title": "Implement Data Access Layer for Session Library",
            "description": "In the new DB service, implement the core CRUD functions for managing session library entries.",
            "dependencies": [
              "48.1"
            ],
            "details": "In `src/lib/session-db.ts`, export asynchronous functions: `addSession(entry: SessionLibraryEntry)`, `getAllSessions(): Promise<SessionLibraryEntry[]>`, and `deleteSession(sessionId: string)`. The `addSession` function should perform an 'upsert' (add or update). `getAllSessions` should retrieve all entries, sorted by `lastOpened` in descending order. `deleteSession` will remove an entry by its ID.",
            "status": "pending",
            "testStrategy": "Manually call these functions from the browser console to add, retrieve, and delete dummy data to confirm they work as expected."
          },
          {
            "id": 3,
            "title": "Integrate Session Saving into File Loader Hook",
            "description": "Modify the existing file loading logic to save session metadata to the IndexedDB library upon a successful load.",
            "dependencies": [
              "48.2"
            ],
            "details": "Locate the `useFileLoader` hook in `src/hooks/useFileLoader.ts`. In the function that processes a file (e.g., `loadFile` or a similar function), after the `SessionMeta` is successfully parsed, call the `addSession` function from `src/lib/session-db.ts`. Construct the `SessionLibraryEntry` object using the `sessionMeta`, the `file.name`, a `new Date().getTime()` for `lastOpened`, and the `fileHandle` if available (from File System Access API).",
            "status": "pending",
            "testStrategy": "Open a `.jsonl` file. Use browser dev tools to inspect IndexedDB and verify that a corresponding session entry has been created with the correct metadata."
          },
          {
            "id": 4,
            "title": "Create Session Library UI Component",
            "description": "Develop a new React component to display the list of saved sessions from IndexedDB.",
            "dependencies": [
              "48.2"
            ],
            "details": "Create a new component `src/components/SessionLibrary.tsx`. This component will use a `useEffect` hook to call `getAllSessions()` on mount and store the results in its state. It will render a list of sessions, displaying key information for each entry like `fileName`, `meta.application`, and a human-readable `lastOpened` time. Include a placeholder for 'Open' and 'Remove' buttons for each item.",
            "status": "pending",
            "testStrategy": "Temporarily add this component to `App.tsx` to verify it correctly fetches and displays the list of sessions previously saved to IndexedDB."
          },
          {
            "id": 5,
            "title": "Integrate Session Library into Welcome Screen",
            "description": "Embed the new Session Library component into the main welcome screen so it's visible on application startup.",
            "dependencies": [
              "48.4"
            ],
            "details": "Modify `src/components/WelcomeScreen.tsx`. Import and render the `SessionLibrary` component. It should be displayed prominently, likely below the existing 'Open File' and drag-and-drop instructions, to provide users with immediate access to their recent sessions.",
            "status": "pending",
            "testStrategy": "Load the application without any session. Verify the list of recent sessions appears on the welcome screen."
          },
          {
            "id": 6,
            "title": "Implement Re-open and Remove Functionality",
            "description": "Wire up the 'Open' and 'Remove' buttons in the Session Library UI to manage and reload sessions.",
            "dependencies": [
              "48.3",
              "48.4"
            ],
            "details": "In `SessionLibrary.tsx`, implement the button logic. The 'Remove' button should call the `deleteSession` DB function and update the component's state to remove the item from the list. The 'Open' button should use the `fileHandle` (if it exists on the entry) to call the appropriate loading function from the `useFileLoader` hook. If no `fileHandle` exists, the 'Open' button should be disabled, with a tooltip explaining that the file must be re-opened manually (e.g., via drag-and-drop).",
            "status": "pending",
            "testStrategy": "Click 'Remove' on a session and verify it disappears from the list and the DB. Click 'Open' on a session that was opened with a file picker and verify it reloads."
          },
          {
            "id": 7,
            "title": "Implement Error Handling and Update Documentation",
            "description": "Add robust error handling for all database operations and document the new feature in the project's README.",
            "dependencies": [
              "48.1",
              "48.6"
            ],
            "details": "In `src/lib/session-db.ts`, wrap all IndexedDB API calls in `try...catch` blocks. Handle potential errors, such as `QuotaExceededError` or DB initialization failures. If the database cannot be used, the Session Library feature should fail gracefully (e.g., the UI component shows an informative message or does not render). Update `README.md` to describe the Session Library feature, its benefits, and any limitations (e.g., the re-open mechanism).",
            "status": "pending",
            "testStrategy": "Test in a browser's private/incognito mode where IndexedDB might be disabled or restricted to ensure the application does not crash. Review the updated `README.md` for clarity."
          }
        ]
      },
      {
        "id": 49,
        "title": "Optimize Large-File Parsing with a Web Worker",
        "description": "Move the JSONL parsing logic into a Web Worker to prevent it from blocking the main UI thread when opening very large files.",
        "details": "Refactor the parser to run in a separate worker script. Use `postMessage` to communicate parsing progress, final results, or errors back to the main thread, which then updates the UI.",
        "testStrategy": "Test loading a very large file (e.g., 100MB+) and verify that the UI remains responsive (e.g., spinners animate smoothly) during the parsing process.",
        "priority": "low",
        "dependencies": [
          31
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 50,
        "title": "Implement Artifact Extraction and Download",
        "description": "Provide a mechanism to locate and download artifacts generated during the session as a bundled zip file.",
        "details": "Parse the session for `Artifact` events. Create a UI to list these artifacts. Use a library like `jszip` to bundle the files client-side and trigger a download.",
        "testStrategy": "Manual test: Load a session containing artifact data. Verify the artifacts are listed and can be downloaded as a single zip archive.",
        "priority": "low",
        "dependencies": [
          31
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 51,
        "title": "Implement Export to HTML",
        "description": "Add an option to export a session report as a self-contained HTML file.",
        "details": "Generate an HTML document string that includes the selected events and necessary CSS for styling. Create a Blob and trigger a client-side download.",
        "testStrategy": "Manual test: Export a session as HTML. Open the downloaded file in a browser and verify it renders correctly without needing external resources.",
        "priority": "low",
        "dependencies": [
          44,
          45
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 52,
        "title": "Enhance Accessibility (a11y)",
        "description": "Perform an accessibility audit and implement improvements, including full keyboard navigation, semantic regions, and color-blind safe markers.",
        "details": "Ensure all interactive elements are focusable and have clear focus states. Use ARIA attributes where necessary. Add distinct visual markers (e.g., patterns, icons) to diffs in addition to color.",
        "testStrategy": "Manual audit using keyboard-only navigation. Run automated accessibility checkers like Axe. Test color-blind safe markers with a simulator.",
        "priority": "low",
        "dependencies": [
          46
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 53,
        "title": "Package as a Desktop App with Electron",
        "description": "Create an Electron wrapper for the web application to provide a native desktop experience and richer file system access.",
        "details": "Set up an Electron project that loads the Vite application. Configure build scripts for packaging the app for major operating systems (Windows, macOS, Linux).",
        "testStrategy": "Build and run the desktop app on a target OS. Verify all functionality works as it does in the browser, and that file system interactions are seamless.",
        "priority": "low",
        "dependencies": [
          29,
          46
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 54,
        "title": "All Sessions View (auto-discovery + selector)",
        "description": "Add a UI to list and search all auto-detected session files (from .codex/sessions, sessions, artifacts/sessions) and allow loading any of them. Keep it lightweight, client-only. Integrate with current loader.",
        "details": "- Build a reusable component `SessionsList` that accepts discovered assets and exposes an `onSelect` callback. \n- Add search, count badge, and sort by filename (desc) with quick actions (copy path, open). \n- Wire into App: show \"View all (N)\" near the session chips and open the list in a modal/card. \n- Reuse existing `handleFile` to load a selected asset (fetch -> blob -> File). \n- Keep discovery in `useAutoDiscovery()`; no runtime fs access. \n- Add docs to README under Usage.",
        "testStrategy": "Manual: add multiple sample .jsonl files under ./.codex/sessions and ./sessions, run dev, click \"View all (N)\", filter, and load a file. Verify Timeline renders and Diff Viewer opens for FileChange events.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `SessionsList` Component Scaffold",
            "description": "Create the basic structure for the `SessionsList` component. It will be a reusable component responsible for displaying a list of discovered session files.",
            "dependencies": [],
            "details": "Create a new file `src/components/SessionsList.tsx`. Define the component to accept `sessions: DiscoveredSession[]` as a prop and an `onSelect: (session: DiscoveredSession) => void` callback. Use Chakra UI components (`List`, `ListItem`, `Flex`, `Box`, `Text`) to render a basic, unstyled list of session paths. For now, the `onSelect` can be triggered via a simple `onClick` on each list item. Include placeholder buttons for 'Copy Path' and 'Open' for each item.",
            "status": "done",
            "testStrategy": "Use Storybook or a temporary mount in `App.tsx` to render the component with mock `DiscoveredSession` data and verify the list appears."
          },
          {
            "id": 2,
            "title": "Implement Search, Sorting, and Count Badge in `SessionsList`",
            "description": "Add stateful filtering and sorting capabilities to the `SessionsList` component to allow users to easily find specific sessions.",
            "dependencies": [
              "54.1"
            ],
            "details": "In `SessionsList.tsx`, add a state for the search query using a Chakra `Input` component. Implement filtering logic to show only sessions whose paths match the query (case-insensitive). Add a `Heading` that includes a count badge, e.g., `All Sessions ({filteredSessions.length})`. Implement sorting logic to display sessions in descending order by filename by default. Use `useMemo` to optimize the filtering and sorting operations.",
            "status": "done",
            "testStrategy": "In the component's test environment, verify that typing in the search input filters the list correctly. Verify the count badge updates. Verify the list is sorted by filename descending by default."
          },
          {
            "id": 3,
            "title": "Integrate `SessionsList` into `App.tsx` via a Modal",
            "description": "Wire the `SessionsList` component into the main application, making it accessible from a trigger near the existing session chips.",
            "dependencies": [
              "54.1"
            ],
            "details": "In `src/App.tsx`, use the `useDisclosure` hook from Chakra UI to manage the modal's state. Add a `Button` or `Chip` next to the quick-access session chips with the text `View all ({discoveredSessions.length})`. The `onClick` of this button should call the `onOpen` function from `useDisclosure`. Render a Chakra `Modal` (`Modal`, `ModalOverlay`, `ModalContent`, `ModalHeader`, `ModalBody`, `ModalCloseButton`) which contains the `SessionsList` component. Pass the `discoveredSessions` from the `useAutoDiscovery` hook to the component.",
            "status": "done",
            "testStrategy": "Run the app. Verify the 'View all (N)' button appears with the correct count. Clicking it should open a modal displaying the full list of sessions from `useAutoDiscovery`."
          },
          {
            "id": 4,
            "title": "Implement Session Loading Logic on Selection",
            "description": "Connect the `onSelect` action in the `SessionsList` to the application's existing file handling logic to load the chosen session.",
            "dependencies": [
              "54.3"
            ],
            "details": "In `App.tsx`, define the function that will be passed as the `onSelect` prop to `SessionsList`. This function will receive the selected `DiscoveredSession`. Inside this function, perform the following: 1. Use the `fetch` API to get the session file content from its public path (`session.path`). 2. Convert the response to a `Blob`. 3. Create a `new File(...)` object from the blob and filename. 4. Call the existing `handleFile` function (from the `useSession` hook) with the new `File` object. 5. Close the modal using the `onClose` function from `useDisclosure`.",
            "status": "done",
            "testStrategy": "Open the 'All Sessions' modal, click on a session. Verify the modal closes and the application loads the selected session, displaying its timeline and metadata."
          },
          {
            "id": 5,
            "title": "Implement Empty/Loading States and Quick Actions",
            "description": "Enhance the `SessionsList` component with better user experience by handling edge cases and implementing the placeholder quick actions.",
            "dependencies": [
              "54.2"
            ],
            "details": "In `SessionsList.tsx`: 1. If the `sessions` prop is empty, display a message like 'No discovered sessions found.'. 2. If the search filter yields no results, display 'No sessions match your search.'. 3. Implement the 'Copy Path' button using `navigator.clipboard.writeText(session.path)`. Provide user feedback with a Chakra `useToast`. 4. Implement the 'Open' button as an `<a>` tag that opens the raw session file (`.jsonl`) in a new tab.",
            "status": "done",
            "testStrategy": "Manually test the empty state by providing an empty array. Test the 'no results' state by searching for gibberish. Test the 'Copy Path' and 'Open' buttons for a few sessions to ensure they work as expected."
          },
          {
            "id": 6,
            "title": "Update README.md with Usage Documentation",
            "description": "Document the new 'All Sessions' view feature for users.",
            "dependencies": [
              "54.3"
            ],
            "details": "Edit the `README.md` file. Add a section under 'Usage' or 'Features' that describes the session auto-discovery and the 'All Sessions' modal. Explain how to access it (by clicking the 'View all' button) and its functionalities, including search and loading a session.",
            "status": "done",
            "testStrategy": "Review the `README.md` file to ensure the new documentation is clear, concise, and accurately reflects the feature's functionality."
          }
        ]
      },
      {
        "id": 55,
        "title": "Reload Sessions Button (re-scan without page refresh)",
        "description": "Add a UI button to re-run session auto-discovery without a full page reload, updating the quick chips and All Sessions list.",
        "details": "- Refactor `useAutoDiscovery()` to expose a `reload()` signal that re-evaluates the globs and updates state. At dev time, Vite HMR should pick up newly added files under watched folders; `reload()` forces the hook to refresh its results.\n- Add a small spinner/disabled state while recalculating.\n- Place the button next to the session chips (and in the All Sessions list header).",
        "testStrategy": "Manual: add a new .jsonl under ./.codex/sessions while dev server runs, click Reload; verify it appears in chips and list. Remove a file, click Reload; verify it's removed. If Vite does not pick it up immediately, note the limitation in README and suggest a page refresh as fallback.",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor `useAutoDiscovery` Hook to Expose `reload` and `loading` State",
            "description": "Modify the `useAutoDiscovery` hook in `src/hooks/useAutoDiscovery.ts` to support manual re-triggering. This involves changing the core logic from a one-time `useEffect` to an on-demand function and adding a loading state.",
            "dependencies": [],
            "details": "In `src/hooks/useAutoDiscovery.ts`, refactor the existing `useEffect` logic into a `useCallback` function, let's call it `scan`. This function will contain the logic for processing the `import.meta.glob` results. Introduce a `useState` boolean for `isLoading`. The hook should call `scan` once on mount. It should return the existing `discoveredSessions` and `sessionCount`, plus the new `isLoading` state and the `scan` function (exposed as `reload`).",
            "status": "pending",
            "testStrategy": "Verify in the browser that sessions still load on the initial page load. Manually call the new `reload` function from the browser console to ensure it can be triggered."
          },
          {
            "id": 2,
            "title": "Add Reload Button to Main App View",
            "description": "Integrate the new `reload` functionality into the main application UI by adding a button next to the session quick-view chips.",
            "dependencies": [
              "55.1"
            ],
            "details": "In `src/App.tsx`, update the call to `useAutoDiscovery` to receive the `reload` function and `isLoading` state. Add a new button, preferably an icon button with a 'refresh' icon, next to the session chips container. The button's `onClick` handler should call the `reload` function. The button should be disabled when `isLoading` is true.",
            "status": "pending",
            "testStrategy": "Manually test by clicking the new reload button. Verify the button becomes disabled during the (brief) reload period."
          },
          {
            "id": 3,
            "title": "Add Reload Button to `AllSessionsView` Component",
            "description": "Add a consistent reload button to the header of the `AllSessionsView` modal/page for a unified user experience.",
            "dependencies": [
              "55.1"
            ],
            "details": "In `src/App.tsx`, pass the `reload` function and `isLoading` state as props to the `AllSessionsView` component. Modify `src/components/AllSessionsView.tsx` to accept these new props. Add a reload button to the component's header, similar to the one in the main view. This button should also call `reload` and be disabled when `isLoading` is true.",
            "status": "pending",
            "testStrategy": "Open the 'All Sessions' view. Click the reload button in its header and verify it triggers the reload and enters a disabled state."
          },
          {
            "id": 4,
            "title": "Implement UI Spinner for Loading Feedback",
            "description": "Provide clear visual feedback during the re-scan process by displaying a spinner next to the reload buttons.",
            "dependencies": [
              "55.2",
              "55.3"
            ],
            "details": "Identify an existing spinner component in the project or create a simple CSS-based one. In both `src/App.tsx` and `src/components/AllSessionsView.tsx`, conditionally render this spinner next to the reload button when the `isLoading` state is true. The refresh icon can be hidden and replaced by the spinner during the loading state.",
            "status": "pending",
            "testStrategy": "Click either reload button and visually confirm that a spinner appears and the button's icon is hidden. The spinner should disappear once the reload is complete."
          },
          {
            "id": 5,
            "title": "Implement Debounce on the `reload` Function",
            "description": "Prevent excessive re-scans from rapid button clicks by adding a debounce mechanism to the `reload` function within the `useAutoDiscovery` hook.",
            "dependencies": [
              "55.1"
            ],
            "details": "In `src/hooks/useAutoDiscovery.ts`, modify the exposed `reload` function. Use a combination of `useRef` to hold a timeout ID and `setTimeout`/`clearTimeout` to create a debounce effect. A debounce delay of 300-500ms is appropriate. This ensures that even if the button is clicked multiple times in quick succession, the expensive `scan` logic only runs once after the user stops clicking.",
            "status": "pending",
            "testStrategy": "Add a `console.log` inside the core scan logic. Click the reload button rapidly multiple times and verify from the console that the log message appears only once after the clicks have stopped."
          },
          {
            "id": 6,
            "title": "Write Unit Tests for `useAutoDiscovery` Hook",
            "description": "Create unit tests for the `useAutoDiscovery` hook to ensure its logic is correct, including the initial load, reload functionality, loading state, and debouncing.",
            "dependencies": [
              "55.1",
              "55.5"
            ],
            "details": "Create a new test file `src/hooks/useAutoDiscovery.test.ts`. Use a testing library (e.g., Vitest, Jest) to mock Vite's `import.meta.glob`. Write test cases to: 1) Verify sessions are loaded on initial render. 2) Verify `isLoading` is `true` while `reload` is executing and `false` otherwise. 3) Verify calling `reload` updates the session list. 4) Use fake timers to test that the debounce logic correctly limits the execution of the scan function.",
            "status": "pending",
            "testStrategy": "Run the test suite and ensure all assertions pass."
          }
        ]
      },
      {
        "id": 56,
        "title": "Newest-First Sorting for Detected Sessions",
        "description": "Add robust newest-first sorting for auto-detected sessions and All Sessions list by parsing timestamps from filenames/directories, with fallback to lexicographic order.",
        "details": "- Parse timestamps from common patterns like `rollout-YYYY-MM-DDTHH-mm-ss`, `YYYY/MM/DD/...`, and ISO-like tokens in the path.\n- Compute and cache a `sortKey` (epoch ms) per asset.\n- Provide a UI toggle between `Newest` and `Name` sort, defaulting to `Newest`.\n- Ensure sorting is stable and resilient when timestamps are missing.",
        "testStrategy": "Manual: seed mixed session filenames; verify order matches expected timestamps. Unit test the parser against representative names and directory patterns.",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Timestamp Parsing Utility",
            "description": "Implement a utility function to extract a timestamp from a file path string. This function will be the core of the sorting logic.",
            "dependencies": [],
            "details": "Create a new file `src/utils/timestamp.ts`. Inside, export a function `parseTimestampFromPath(path: string): number | null`. This function should use regular expressions to find and parse timestamps from the following patterns in order of priority:\n1. `rollout-YYYY-MM-DDTHH-mm-ss` in the filename.\n2. ISO 8601-like date strings (e.g., `YYYY-MM-DDTHH-mm-ss.sssZ`) anywhere in the path.\n3. Directory structures like `YYYY/MM/DD/`.\nReturn the parsed timestamp as epoch milliseconds, or `null` if no recognizable timestamp is found.",
            "status": "pending",
            "testStrategy": "This will be tested directly in subtask 56.5."
          },
          {
            "id": 2,
            "title": "Integrate Timestamp Parsing into `useAutoDiscovery` Hook",
            "description": "Modify the auto-discovery hook to compute and attach a `sortKey` to each discovered session object.",
            "dependencies": [
              "56.1"
            ],
            "details": "In `src/hooks/useAutoDiscovery.ts`:\n1. Update the `DiscoveredSession` interface to include `sortKey: number | null`.\n2. Import `parseTimestampFromPath` from `src/utils/timestamp.ts`.\n3. Within the `useEffect` that processes the `glob` results, call `parseTimestampFromPath` for each file's path.\n4. Attach the returned epoch milliseconds (or `null`) to the new `sortKey` property of the `DiscoveredSession` object being created.",
            "status": "pending",
            "testStrategy": "Manual verification by inspecting the hook's output with a debugger or console log."
          },
          {
            "id": 3,
            "title": "Add Sort Toggle UI to All Sessions Modal",
            "description": "Implement the UI controls for switching between 'Newest' and 'Name' sorting within the 'All Sessions' list.",
            "dependencies": [],
            "details": "In `src/components/AllSessionsModal.tsx`:\n1. Add a new state variable: `const [sortOrder, setSortOrder] = useState<'newest' | 'name'>('newest');`.\n2. In the modal's header area, add a simple button group or segmented control that allows the user to select between 'Newest' and 'Name'.\n3. The onClick handler for these controls should update the `sortOrder` state.\n4. Ensure the default selection is 'Newest'.",
            "status": "pending",
            "testStrategy": "Manually open the 'All Sessions' modal and verify the toggle UI is present, defaults to 'Newest', and can be changed."
          },
          {
            "id": 4,
            "title": "Implement Stable Sorting Logic",
            "description": "Apply the sorting logic based on the selected sort order, ensuring a stable sort and proper fallback for items without a timestamp.",
            "dependencies": [
              "56.2",
              "56.3"
            ],
            "details": "In `src/components/AllSessionsModal.tsx`, replace the existing `a.name.localeCompare(b.name)` sort.\n1. Create a new sorted list based on the `sortOrder` state.\n2. If `sortOrder` is `'newest'`, sort by `b.sortKey - a.sortKey`. For items where `sortKey` is `null` or equal, use `a.name.localeCompare(b.name)` as a secondary, stable sort criterion.\n3. If `sortOrder` is `'name'`, sort by `a.name.localeCompare(b.name)`.\n4. In `src/components/WelcomeScreen.tsx`, apply the default 'newest' sorting logic to the session chips it displays from `useAutoDiscovery`. No UI toggle is needed here, just the default sort behavior.",
            "status": "pending",
            "testStrategy": "Manually test with a mix of session files (some with timestamps in the name, some without) and verify that the list order in the modal and on the welcome screen is correct. Check that toggling the sort order works as expected."
          },
          {
            "id": 5,
            "title": "Write Unit Tests for Timestamp Parser",
            "description": "Create a suite of unit tests to ensure the `parseTimestampFromPath` utility is robust and handles various path formats correctly.",
            "dependencies": [
              "56.1"
            ],
            "details": "Create a new test file `src/utils/timestamp.test.ts`.\nUsing Vitest (or the project's testing framework), write tests for `parseTimestampFromPath` that cover:\n- Each of the specified patterns (`rollout-`, ISO-like, `YYYY/MM/DD`).\n- Paths containing no timestamp (should return `null`).\n- Paths with malformed or invalid dates.\n- Edge cases like paths with multiple potential timestamps (ensure priority is handled correctly).",
            "status": "pending",
            "testStrategy": "Run `npm test` (or equivalent) and ensure all tests pass."
          },
          {
            "id": 6,
            "title": "Update README with Sorting Behavior Documentation",
            "description": "Document the new sorting feature, its default behavior, and the filename patterns it recognizes.",
            "dependencies": [],
            "details": "In `README.md`, add a new section under 'Features' titled 'Session Sorting'.\nExplain that sessions are sorted by newest first by default. Detail the specific filename and directory patterns that the application recognizes for timestamp extraction, listing them in order of priority. Mention that it falls back to alphabetical sorting by name if no timestamp is found.",
            "status": "pending",
            "testStrategy": "Review the `README.md` file to confirm the new section is clear and accurate."
          }
        ]
      },
      {
        "id": 57,
        "title": "Complete Diff Viewer Functionality",
        "description": "Make the Diff Viewer robust for real-world diffs and add essential controls.",
        "details": "- Parser resilience: handle diffs without @@ hunks; tolerate missing ---/+++ headers; keep context lines; ignore 'No newline at end of file'.\n- Viewer controls: toggles for side-by-side vs inline, word wrap, ignore whitespace; copy and download raw diff; surface language.\n- Large/binary guards: show clear notices and allow opening raw.\n- Tests: unit tests for the diff parser and a couple of snapshot tests for the viewer config.\n- Docs: expand README Diff Viewer section and note supported formats/limits.",
        "testStrategy": "Unit tests for parser branches; manual test with diverse diffs (single-hunk, multi-hunk, headerless, only +/- lines, and binary-looking).",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Enhance Diff Parser for Headerless and Hunkless Diffs",
            "description": "Modify the diff parsing logic to robustly handle diffs that lack standard '---'/'+++' headers or '@@' hunk specifiers. The parser should correctly process context, added, and removed lines based on their prefixes (' ', '+', '-') and ignore '\\ No newline at end of file' lines.",
            "dependencies": [],
            "details": "Locate the primary diff parsing function, likely `parseUnifiedDiffToSides` in a file such as `src/utils/diffParser.ts`. Update its logic to check for the presence of `---`/`+++` headers. If they are absent, treat the entire input as a single file change. Iterate through each line, assigning it to the 'left' (for '-' and ' ' prefixes) or 'right' (for '+' and ' ' prefixes) side of the diff. Ensure lines starting with '\\' are skipped.",
            "status": "pending",
            "testStrategy": "Add unit tests for various diff formats: headerless, hunkless, mixed, and standard unified diffs."
          },
          {
            "id": 2,
            "title": "Implement Viewer Controls for Display Modes",
            "description": "Add UI controls to the Diff Viewer for toggling between side-by-side and inline views, enabling/disabling word wrap, and ignoring whitespace changes. These settings should be managed by local component state.",
            "dependencies": [],
            "details": "In the `DiffViewer.tsx` component, introduce `useState` hooks to manage `renderSideBySide` (boolean), `wordWrap` ('on'/'off'), and `ignoreTrimWhitespace` (boolean). Add UI elements (e.g., buttons or switches from the project's component library) to the viewer's header area to modify these state variables. Pass these values to the `options` prop of the Monaco `DiffEditor` component to control its behavior.",
            "status": "pending",
            "testStrategy": "Manually verify that toggling each control correctly updates the Monaco editor's display style."
          },
          {
            "id": 3,
            "title": "Add 'Copy Raw' and 'Download Raw' Actions",
            "description": "Implement two new actions in the Diff Viewer's header: a 'Copy raw' button to copy the original diff text to the clipboard, and a 'Download raw' button to save the diff text as a file.",
            "dependencies": [],
            "details": "In `DiffViewer.tsx`, add two new buttons. For 'Copy raw', use the `navigator.clipboard.writeText()` API with the raw `diff` string prop. For 'Download raw', reuse the file download utility function from existing export features (see Task 44). Create a `Blob` from the raw `diff` string with MIME type `text/plain` and trigger a download. The filename should be derived from the file path, e.g., `path-to-file.diff`.",
            "status": "pending",
            "testStrategy": "Click 'Copy raw' and paste into a text editor. Click 'Download raw' and verify the contents of the downloaded file."
          },
          {
            "id": 4,
            "title": "Implement Guards for Large and Binary Diffs",
            "description": "Add detection for large or binary diffs. Instead of attempting to render them, display a clear notification message and provide an option to view or download the raw content.",
            "dependencies": [
              "57.3"
            ],
            "details": "In `DiffViewer.tsx`, before rendering the editor, add a pre-processing step. Check the raw `diff` string for binary content (e.g., presence of null bytes `\\0`) or excessive length (e.g., > 1MB or > 10,000 lines). If a guard is triggered, render a message like 'Binary file diff cannot be displayed.' or 'Diff is too large to display.' and show a 'Download Raw Diff' button that reuses the logic from subtask 3.",
            "status": "pending",
            "testStrategy": "Test with a very large text file diff and a diff from a binary file (e.g., an image) to ensure the notice appears correctly."
          },
          {
            "id": 5,
            "title": "Refine Language Detection for Syntax Highlighting",
            "description": "Improve the language detection logic to correctly map common file extensions to their corresponding Monaco Editor language identifiers, such as mapping 'tsx' to 'typescript' and 'yml' to 'yaml'.",
            "dependencies": [],
            "details": "In `DiffViewer.tsx` or a new utility file (`src/utils/languageDetection.ts`), create or update the function that determines the language for Monaco. This function will take the file path (e.g., `newPath` prop) as input. Implement a mapping object or a switch statement to handle aliases: `tsx` -> `typescript`, `jsx` -> `javascript`, `yml` -> `yaml`, `py` -> `python`, etc. The result should be passed to the `language` prop of the `DiffEditor`.",
            "status": "pending",
            "testStrategy": "Load diffs for `.tsx`, `.jsx`, and `.yml` files and verify that syntax highlighting is applied correctly."
          },
          {
            "id": 6,
            "title": "Add Unit Tests for Diff Parser Resilience",
            "description": "Create a suite of unit tests for the diff parsing function to ensure it correctly handles the newly supported formats and does not regress on standard formats.",
            "dependencies": [
              "57.1"
            ],
            "details": "Create a new test file, `src/utils/diffParser.test.ts`, using the project's testing framework (e.g., Jest/Vitest). Write specific test cases for the `parseUnifiedDiffToSides` function, covering: a diff with only `+` and `-` lines, a diff without `---`/`+++` headers, a diff with context lines but no hunk `@@` header, and a diff containing the 'No newline at end of file' string. Also include a test for a standard, well-formed diff.",
            "status": "pending",
            "testStrategy": "Run the test suite and ensure all assertions pass for the various diff input scenarios."
          },
          {
            "id": 7,
            "title": "Create Snapshot Test for Diff Viewer Options",
            "description": "Add a component-level snapshot test for the Diff Viewer to capture its rendering with different view options, ensuring UI consistency and preventing regressions.",
            "dependencies": [
              "57.2"
            ],
            "details": "In the Storybook file for the diff viewer, likely `src/components/DiffViewer/DiffViewer.stories.tsx`, create several stories. One story should render the viewer in its default state. Add other stories that pass props to enable different options, such as `{ renderSideBySide: false }` for inline view and `{ options: { wordWrap: 'on' } }` for word wrap. If snapshot testing is configured (e.g., via `@storybook/addon-storyshots`), these stories will generate snapshots.",
            "status": "pending",
            "testStrategy": "Generate snapshots for the new stories. On subsequent changes, verify that snapshot diffs are intentional."
          },
          {
            "id": 8,
            "title": "Update README with Diff Viewer Capabilities",
            "description": "Expand the 'Diff Viewer' section in the project's README.md to document the new features, supported formats, UI controls, and known limitations.",
            "dependencies": [],
            "details": "Edit the `README.md` file. Locate the section on the Diff Viewer. Add details about the enhanced parser's resilience (e.g., 'Handles headerless diffs'). List the new viewer controls (Side-by-side/inline toggle, Word Wrap, etc.). Mention the handling of large and binary files. Include a simple code block example of a diff that is now supported.",
            "status": "pending",
            "testStrategy": "Review the rendered `README.md` on the Git hosting platform to ensure the formatting is correct and the information is clear."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-08T17:44:30.733Z",
      "updated": "2025-09-09T02:03:50.018Z",
      "description": "Tasks for master context"
    }
  }
}