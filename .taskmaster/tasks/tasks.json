{
  "master": {
    "tasks": [
      {
        "id": 67,
        "title": "Setup Foundational Chat API with Mastra Agent",
        "description": "Create a new API route `/api/sessions/[id]/chat` that uses the Mastra agent framework. The agent should be initialized with a `get_session` tool that wraps the existing `lib/db.ts#getSession` function to provide session context.",
        "details": "This is the first step of the MVP. The API route should accept a POST request with the user's question. It needs to instantiate a Mastra agent, invoke it with the question and the session context from the tool, and prepare for streaming responses. This task focuses on the backend wiring, not the UI or streaming itself yet.",
        "testStrategy": "Create a unit test for the `get_session` tool to ensure it correctly fetches and formats session data. Use an API testing tool like Postman or curl to send a request to the new endpoint and verify it returns a non-empty, non-streamed response from the agent for now.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Create User Database Schema",
            "description": "Define and create the necessary database table(s) to store user information, including credentials and profile data.",
            "dependencies": [],
            "details": "Create a 'users' table with columns for 'id' (primary key), 'email' (unique), 'password_hash' (string), 'created_at', and 'updated_at'. Use a database migration script to apply the schema. Ensure passwords are not stored in plain text.",
            "status": "pending",
            "testStrategy": "Verify the table and its columns are created correctly in the development database. Write a unit test for the migration script to ensure it runs up and down without errors."
          },
          {
            "id": 2,
            "title": "Develop API Endpoints for User Registration and Login",
            "description": "Create the backend API endpoints for user registration (`/api/auth/register`) and user login (`/api/auth/login`).",
            "dependencies": [],
            "details": "The registration endpoint should accept email and password, hash the password using bcrypt, and save the new user to the database. The login endpoint should validate credentials, and upon success, generate and return a JSON Web Token (JWT).",
            "status": "pending",
            "testStrategy": "Write integration tests for both endpoints. Test successful registration, duplicate email registration attempts, successful login with correct credentials, and failed login with incorrect credentials. Validate the structure of the returned JWT."
          },
          {
            "id": 3,
            "title": "Create Frontend UI for Registration and Login Forms",
            "description": "Build the user interface components for the registration and login pages using the chosen frontend framework.",
            "dependencies": [],
            "details": "Create two separate routes/pages: `/register` and `/login`. Each page should have a form with input fields for email and password, and a submit button. Implement basic client-side validation for email format and password strength. On form submission, make an API call to the corresponding endpoint.",
            "status": "pending",
            "testStrategy": "Use component tests to verify the forms render correctly and that client-side validation logic works as expected. Use UI snapshots to prevent unintended visual regressions."
          },
          {
            "id": 4,
            "title": "Implement Client-Side State Management and Protected Routes",
            "description": "Manage the user's authentication state within the frontend application, including storing tokens and protecting routes from unauthorized access.",
            "dependencies": [],
            "details": "Upon successful login, store the received JWT securely in an HttpOnly cookie. Create a global state or context to hold user information and authentication status. Implement a 'protected route' wrapper that redirects unauthenticated users to the login page. Create a 'logout' function that clears the token and user state.",
            "status": "pending",
            "testStrategy": "Write end-to-end tests to verify that a user can log in, access a protected route, log out, and then be denied access to the same protected route. Unit test the state management logic (e.g., context providers or store actions)."
          }
        ]
      },
      {
        "id": 68,
        "title": "Implement Local/Cloud Model Switching Configuration",
        "description": "Create a configuration module that allows switching between a local Nexa server and a cloud-based OpenAI-compatible provider. Use environment variables (`LLM_BASE_URL`, `LLM_API_KEY`, `LLM_MODEL_NAME`) to configure the OpenAI client.",
        "details": "This task is critical for privacy and flexibility. The implementation should provide a factory function or a singleton client instance that is configured on startup based on environment variables. This ensures that all agent calls use the correct endpoint without needing provider-specific code in the business logic.",
        "testStrategy": "Write unit tests to verify that the client is configured correctly for both local (Nexa) and cloud scenarios based on mock environment variables. Test that a dummy API key is used for local connections as specified in the PRD.",
        "priority": "high",
        "dependencies": [
          67
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the necessary database table to store user information, including email, hashed password, and timestamps.",
            "dependencies": [],
            "details": "Using a database migration tool, create a 'users' table. The table should include columns: 'id' (primary key, e.g., UUID), 'email' (unique, indexed), 'hashed_password' (string), 'created_at' (timestamp), and 'updated_at' (timestamp).",
            "status": "pending",
            "testStrategy": "Run the migration against a test database and verify the schema. Write a unit test to confirm that a model object can be created, saved, and retrieved successfully."
          },
          {
            "id": 2,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., POST /api/register) that allows new users to create an account.",
            "dependencies": [],
            "details": "The endpoint should accept an email and password. It must validate the input, check for existing users with the same email, and hash the password using bcrypt before storing the new user record in the database. Return a 201 status on success or appropriate error codes (400 for bad input, 409 for conflict).",
            "status": "pending",
            "testStrategy": "Write integration tests to cover successful registration, registration with a duplicate email, and registration with invalid input (e.g., invalid email format, weak password). Verify that the password stored in the database is properly hashed."
          },
          {
            "id": 3,
            "title": "Implement User Login API Endpoint with JWT",
            "description": "Create an API endpoint (e.g., POST /api/login) for users to authenticate and receive a JSON Web Token (JWT).",
            "dependencies": [],
            "details": "The endpoint should accept an email and password. It will find the user by email, compare the provided password with the stored hash. If credentials are valid, generate a JWT containing the user ID and an expiration claim. Return the JWT to the client. Handle invalid login attempts with a generic error message.",
            "status": "pending",
            "testStrategy": "Write integration tests for successful login with correct credentials, failed login with an incorrect password, and failed login for a non-existent user. For successful logins, validate the structure and signature of the returned JWT."
          }
        ]
      },
      {
        "id": 69,
        "title": "Implement Streaming SSE and Frontend Chat UI",
        "description": "Enhance the `/api/sessions/[id]/chat` endpoint to stream responses using Server-Sent Events (SSE). On the frontend, modify `app/sessions/[id]/page.tsx` to include a new 'Chat' tab with a message input and a display area that renders the streamed tokens.",
        "details": "The backend will use the agent's `.stream()` method and pipe the output to an SSE response. The frontend will use the `EventSource` API to listen for tokens and append them to the chat display. The UI should include a form for sending new messages and display conversation history.",
        "testStrategy": "Manually test the chat UI in the browser. Ask a question that generates a long response and verify that tokens appear within 2 seconds. Check the browser's network tab to confirm an `EventSource` connection is established and receiving data. Add a BDD test case for the streaming acceptance criteria.",
        "priority": "high",
        "dependencies": [
          67
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the necessary database table(s) to store user information, including credentials and profile data, to support the authentication system.",
            "dependencies": [],
            "details": "Using a database migration tool, create a 'users' table. The table should include columns such as 'id' (UUID, primary key), 'email' (VARCHAR, unique, not null), 'password_hash' (VARCHAR, not null), 'created_at' (TIMESTAMP), and 'updated_at' (TIMESTAMP).",
            "status": "pending",
            "testStrategy": "Run the migration to create the table. Verify the schema in the database manually or with a schema inspection tool. Write a test for the migration to ensure it can be applied and reverted successfully."
          },
          {
            "id": 2,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., POST /api/auth/register) that allows new users to create an account.",
            "dependencies": [],
            "details": "The endpoint must accept 'email' and 'password' in the request body. It should validate the input (e.g., valid email format, password complexity). Use a strong hashing algorithm like bcrypt to hash the password before storing it in the 'users' table. Return a 201 Created status on success.",
            "status": "pending",
            "testStrategy": "Write integration tests to cover successful registration, registration with a duplicate email (expect a 409 Conflict), and registration with invalid input (e.g., weak password, invalid email format, expect a 400 Bad Request)."
          },
          {
            "id": 3,
            "title": "Implement User Login API Endpoint with JWT Generation",
            "description": "Create a public API endpoint (e.g., POST /api/auth/login) for users to authenticate and receive a JSON Web Token (JWT).",
            "dependencies": [],
            "details": "The endpoint should accept 'email' and 'password'. It will find the user by email, then use bcrypt's compare function to verify the password against the stored hash. If credentials are valid, generate a signed JWT containing the user's ID and role in the payload. The token must have an expiration time. Return the JWT in the response body.",
            "status": "pending",
            "testStrategy": "Write integration tests for successful login (expect a 200 OK and a JWT), login with an incorrect password (expect a 401 Unauthorized), and login with a non-existent email (expect a 401 Unauthorized)."
          },
          {
            "id": 4,
            "title": "Create JWT Authentication Middleware",
            "description": "Develop a middleware function that can be applied to API routes to ensure only authenticated users can access them.",
            "dependencies": [],
            "details": "The middleware will extract the JWT from the 'Authorization: Bearer <token>' header. It must verify the token's signature and check if it has expired. If the token is valid, decode the payload to get the user ID and attach the user's identity to the request object (e.g., req.user). If the token is missing, invalid, or expired, the middleware must respond with a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Write unit tests for the middleware logic. Test scenarios with a valid token, an invalid/tampered token, an expired token, and a missing token. Ensure the correct HTTP status code is returned in each failure case and that 'next()' is called on success."
          },
          {
            "id": 5,
            "title": "Implement a Protected User Profile Route",
            "description": "Create an example protected route (e.g., GET /api/users/me) that returns the current authenticated user's data.",
            "dependencies": [],
            "details": "Create a new route GET /api/users/me and apply the JWT authentication middleware to it. The route handler will use the user ID from the request object (populated by the middleware) to fetch the user's details from the database. The response should include non-sensitive data like 'id' and 'email'.",
            "status": "pending",
            "testStrategy": "Write an integration test that first calls the login endpoint to obtain a valid JWT. Then, use that JWT to make a request to the protected profile route and assert that the correct user data is returned. Also, test the route without a token and with an invalid token to ensure a 401 Unauthorized error is returned."
          }
        ]
      },
      {
        "id": 70,
        "title": "Implement Conversation Memory with LibSQL",
        "description": "Integrate Mastra's Memory feature to persist chat history for each session. Use the existing LibSQL connection (`@libsql/client`) to create and manage a `memory` table to store conversation messages.",
        "details": "The schema for the memory table should include `userId`, `sessionId`, `messages` (as JSON), and `lastUsedAt`. The chat API will be updated to load memory at the start of a conversation and save it at the end. This enables follow-up questions.",
        "testStrategy": "After a chat conversation, inspect the LibSQL database file or Turso table to verify that a corresponding memory record has been created or updated. Start a new chat session on the same page and ask a follow-up question to confirm the agent uses the previous context.",
        "priority": "medium",
        "dependencies": [
          69
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Create User Database Schema",
            "description": "Define and create the necessary database table(s) to store user information, including credentials and profile data.",
            "dependencies": [],
            "details": "Create a 'users' table with columns for 'id' (primary key, auto-increment), 'email' (unique, indexed), 'password_hash' (string), 'full_name' (string), 'created_at' (timestamp), and 'updated_at' (timestamp). Use a database migration tool like Alembic or Flyway to script the schema creation.",
            "status": "pending",
            "testStrategy": "Run the migration script against a test database. Verify that the 'users' table and all specified columns with their constraints (e.g., uniqueness on email) are created correctly. Write a test to ensure the migration can be applied and reverted successfully."
          },
          {
            "id": 2,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., POST /api/v1/users/register) that allows new users to create an account.",
            "dependencies": [],
            "details": "The endpoint should accept 'email', 'password', and 'full_name'. It must validate input: check for a valid email format, enforce password complexity rules, and ensure the email is not already in use. Hash the password using a strong, salted algorithm like bcrypt before storing it in the database. On success, return a 201 Created status with the newly created user's ID and email.",
            "status": "pending",
            "testStrategy": "Write integration tests for: 1) Successful registration with valid data. 2) Failed registration due to a duplicate email. 3) Failed registration due to an invalid email format. 4) Failed registration due to a weak password. 5) Verify that the password stored in the database is a hash and not plaintext."
          },
          {
            "id": 3,
            "title": "Develop User Login API Endpoint and JWT Generation",
            "description": "Create an endpoint (e.g., POST /api/v1/auth/login) for users to authenticate and receive a JSON Web Token (JWT).",
            "dependencies": [],
            "details": "The endpoint should accept 'email' and 'password'. It will find the user by email, then use bcrypt's compare function to verify the password against the stored hash. If credentials are valid, generate a signed JWT containing the user's ID, role (if any), and an expiration claim (e.g., 1 hour). Return the JWT in the response body.",
            "status": "pending",
            "testStrategy": "Write integration tests for: 1) Successful login with correct credentials, verifying a valid JWT is returned. 2) Failed login with an incorrect password. 3) Failed login with a non-existent email. Ensure error responses are generic (e.g., 'Invalid credentials') to prevent user enumeration attacks."
          },
          {
            "id": 4,
            "title": "Implement Authentication Middleware for Protected Routes",
            "description": "Create a middleware that intercepts requests to protected endpoints, validates the JWT from the Authorization header, and attaches the authenticated user's data to the request context.",
            "dependencies": [],
            "details": "The middleware should parse the 'Bearer <token>' from the 'Authorization' header. It will verify the JWT's signature and check if it has expired. If the token is valid, extract the user ID from the payload, fetch the user from the database, and attach the user object to the request for downstream handlers. If the token is invalid, missing, or expired, the middleware should immediately respond with a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Create a sample protected endpoint (e.g., GET /api/v1/profile/me). Write integration tests to: 1) Access the endpoint with a valid JWT and verify a 200 OK response. 2) Access the endpoint with an invalid/malformed JWT and verify a 401 Unauthorized response. 3) Access the endpoint with an expired JWT and verify a 401 Unauthorized response. 4) Access the endpoint with no Authorization header and verify a 401 Unauthorized response."
          }
        ]
      },
      {
        "id": 71,
        "title": "Backend for One-Click Session Summary",
        "description": "Create a new API route `/api/sessions/[id]/summarize` that uses the Session Analyst agent to generate a summary. The summary should be stored in a new `summaries` table in the database, linked to the session ID.",
        "details": "The agent will be given a specific instruction to summarize the session content, focusing on key errors, fixes, and commands. The resulting summary object will be persisted using the LibSQL client. The API should return the generated summary upon completion.",
        "testStrategy": "Call the `/summarize` endpoint for a session with >100 log lines. Verify that a `200 OK` is returned and that a new record appears in the `summaries` table. Validate that the stored summary content is structured with the required sections.",
        "priority": "medium",
        "dependencies": [
          67
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Set Up User Authentication Database Schema",
            "description": "Create the necessary database tables and fields to store user information, including credentials and profile data.",
            "dependencies": [],
            "details": "Define a `users` table with columns like `id` (primary key), `email` (unique), `hashed_password`, `created_at`, and `updated_at`. Use a database migration tool (e.g., Alembic, Flyway) to create and version the schema. Ensure email field is indexed for fast lookups.",
            "status": "pending",
            "testStrategy": "Run the migration script and verify the table structure and constraints directly in the database. Write a unit test to confirm the migration runs without errors and the `users` table is created as expected."
          },
          {
            "id": 2,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., POST /api/users/register) that allows new users to create an account.",
            "dependencies": [],
            "details": "The endpoint should accept `email` and `password`. It must validate the input: check for a valid email format, enforce password complexity rules, and ensure the email is not already registered. Use a strong hashing algorithm like bcrypt to hash the password before storing it in the database. Return a 201 Created status on success.",
            "status": "pending",
            "testStrategy": "Write integration tests to cover successful registration, registration with a duplicate email, registration with an invalid email format, and registration with a weak password. Use an API client like Postman or automated test scripts to check responses and status codes."
          },
          {
            "id": 3,
            "title": "Develop User Login API Endpoint and Token Generation",
            "description": "Create an API endpoint (e.g., POST /api/auth/login) for users to authenticate and receive a JSON Web Token (JWT).",
            "dependencies": [],
            "details": "The endpoint should accept `email` and `password`. It will find the user by email, compare the provided password against the stored hash using the bcrypt compare function. If credentials are valid, generate a signed JWT containing the user ID and an expiration claim. Return the JWT in the response body.",
            "status": "pending",
            "testStrategy": "Write integration tests for successful login with correct credentials, and failed login attempts with an incorrect password or non-existent email. Verify that a structurally valid JWT is returned on successful login."
          },
          {
            "id": 4,
            "title": "Implement Authentication Middleware for Protected Routes",
            "description": "Create a middleware to secure specific API routes, requiring a valid JWT for access.",
            "dependencies": [],
            "details": "The middleware should be applied to protected routes. It will extract the JWT from the `Authorization` header (e.g., 'Bearer <token>'). It must then verify the token's signature and check for expiration. If the token is valid, attach the user's information to the request object for use in the route handler. If invalid, return a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Create a sample protected endpoint. Write integration tests that attempt to access this endpoint with a valid JWT (should succeed), with an invalid or expired JWT (should return 401), and with no JWT (should return 401)."
          }
        ]
      },
      {
        "id": 72,
        "title": "Frontend UI for Session Summary",
        "description": "On the session page (`app/sessions/[id]/page.tsx`), add a 'Summarize session' button. When clicked, this button should call the summarize API. A new UI panel should be added to display the stored summary, with sections for Errors, Fixes, and Commands.",
        "details": "The page should first check if a summary already exists for the session and display it on load. The button should be disabled while a summary is being generated. The summary panel should be clearly distinct from the main log view.",
        "testStrategy": "Load a session page. Click the 'Summarize session' button and verify a loading state appears. Once complete, confirm the summary panel is populated correctly. Reload the page and ensure the summary is displayed immediately without needing to click the button again.",
        "priority": "medium",
        "dependencies": [
          71
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Set Up User Database Schema",
            "description": "Create the necessary database tables to store user information, including credentials and profile data, using a migration script.",
            "dependencies": [],
            "details": "Define a 'users' table with columns for 'id' (primary key), 'email' (unique), 'password_hash' (string), 'created_at', and 'updated_at'. Use a database migration tool (e.g., Flyway, Alembic) to create and version the schema.",
            "status": "pending",
            "testStrategy": "Run the migration script and verify that the 'users' table and its columns are created correctly in the development database. Write a unit test to ensure the migration can be applied and reverted successfully."
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., POST /api/register) that allows new users to create an account by providing their email and password.",
            "dependencies": [],
            "details": "The endpoint should validate input data (e.g., valid email format, password strength). It must hash the password using a strong algorithm like bcrypt before storing the new user record in the database. Return a success message or the created user object (without the password hash).",
            "status": "pending",
            "testStrategy": "Write integration tests to cover: 1) Successful registration with valid data. 2) Attempted registration with a duplicate email. 3) Attempted registration with invalid input (e.g., weak password, invalid email format)."
          },
          {
            "id": 3,
            "title": "Implement User Login and JWT Generation",
            "description": "Create an API endpoint (e.g., POST /api/login) for users to authenticate and receive a JSON Web Token (JWT).",
            "dependencies": [],
            "details": "The endpoint will accept 'email' and 'password'. It should retrieve the user by email, compare the provided password against the stored hash using the bcrypt compare function, and if valid, generate a signed JWT containing the user ID and an expiration claim.",
            "status": "pending",
            "testStrategy": "Write integration tests for: 1) Successful login with correct credentials, verifying a valid JWT is returned. 2) Failed login with an incorrect password. 3) Failed login for a non-existent user email."
          },
          {
            "id": 4,
            "title": "Create Authentication Middleware for Protected Routes",
            "description": "Develop middleware to verify the JWT on incoming requests to secure specific endpoints.",
            "dependencies": [],
            "details": "The middleware should extract the JWT from the 'Authorization: Bearer <token>' header. It must verify the token's signature and check for expiration. If valid, decode the payload and attach the user's identity to the request context. If invalid or missing, it must return a 401 Unauthorized status.",
            "status": "pending",
            "testStrategy": "Apply the middleware to a test endpoint. Write integration tests to: 1) Access the endpoint with a valid token. 2) Access with an expired token. 3) Access with an invalid/malformed token. 4) Access with no token. Ensure correct HTTP status codes are returned."
          }
        ]
      },
      {
        "id": 73,
        "title": "Implement Embeddings Generation for Semantic Search",
        "description": "Create a background process or script to generate embeddings for all sessions. This process will read session data, chunk it, and call the `/v1/embeddings` endpoint (local Nexa or cloud) to get vectors, which are then stored in a new `embeddings` table.",
        "details": "The `embeddings` table should store the vector, the original text chunk, and the `sessionId`. The script should be idempotent, allowing it to be re-run to update or backfill embeddings for sessions that don't have them.",
        "testStrategy": "Run the script on a sample of sessions. Inspect the `embeddings` table to confirm that vector data has been populated. Verify that the dimensions of the stored vectors match the output of the embedding model being used.",
        "priority": "medium",
        "dependencies": [
          68
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the necessary database table(s) to store user information, including credentials and profile data.",
            "dependencies": [],
            "details": "Create a 'users' table with columns for id (primary key), username (unique), email (unique), hashed_password, created_at, and updated_at. Use a database migration tool to manage the schema changes.",
            "status": "pending",
            "testStrategy": "Verify the migration runs successfully. Write a unit test to connect to a test database and confirm the 'users' table and its columns exist with the correct data types and constraints."
          },
          {
            "id": 2,
            "title": "Create User Registration API Endpoint",
            "description": "Develop a public API endpoint (e.g., POST /api/users/register) that allows new users to create an account.",
            "dependencies": [],
            "details": "The endpoint should accept a username, email, and password. It must validate the input, check for existing username/email, hash the password using bcrypt, and save the new user to the database. Return a success message or user object upon successful registration.",
            "status": "pending",
            "testStrategy": "Write integration tests to cover: 1) Successful registration with valid data. 2) Failed registration with a duplicate username/email. 3) Failed registration with invalid input (e.g., weak password). 4) Verify the password stored in the database is hashed."
          },
          {
            "id": 3,
            "title": "Implement User Login and JWT Generation",
            "description": "Create an API endpoint (e.g., POST /api/auth/login) for users to log in and receive an authentication token.",
            "dependencies": [],
            "details": "The endpoint should accept a username/email and password. It will find the user in the database and compare the provided password with the stored hash. If they match, generate a JSON Web Token (JWT) containing the user ID and an expiration date. Return the JWT to the client.",
            "status": "pending",
            "testStrategy": "Write integration tests for: 1) Successful login with correct credentials, verifying a valid JWT is returned. 2) Failed login with an incorrect password. 3) Failed login with a non-existent username. 4) Test the JWT payload to ensure it contains the correct user ID and an expiration claim."
          },
          {
            "id": 4,
            "title": "Develop Authentication Middleware for Protected Routes",
            "description": "Create a middleware that can be applied to API endpoints to ensure only authenticated users can access them.",
            "dependencies": [],
            "details": "The middleware should extract the JWT from the 'Authorization' header. It must validate the token's signature and expiration. If valid, it should identify the user from the token's payload and attach the user object to the request context. If the token is invalid or missing, it should return a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Create a dummy protected endpoint. Write tests to: 1) Access the endpoint with a valid JWT and expect a 200 OK response. 2) Access the endpoint with an invalid or expired JWT and expect a 401 Unauthorized response. 3) Access the endpoint with no JWT and expect a 401 Unauthorized response."
          }
        ]
      },
      {
        "id": 74,
        "title": "Create Semantic Search API with Keyword Fallback",
        "description": "Implement a new API route `GET /api/search?q=` that performs semantic search. The route will first generate an embedding for the query `q`, then perform a top-k vector search against the `embeddings` table. Implement a fallback to keyword-based search if no embeddings are available.",
        "details": "The vector search can be implemented with a cosine similarity function in SQL for LibSQL, or using pgvector functions if Postgres is available. The API should return a list of session results ordered by similarity score. If the fallback is used, the response should include an indicator.",
        "testStrategy": "Test the API with a conceptual query (e.g., 'cache problems'). Verify that the returned sessions are semantically related and ordered by score. Then, temporarily disable embeddings and re-run the search to ensure the system gracefully falls back to keyword search and includes the 'fallback' indicator in the response.",
        "priority": "medium",
        "dependencies": [
          73
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the necessary database tables to store user information, including credentials and profile data, using a migration script.",
            "dependencies": [],
            "details": "Create a `users` table with columns: `id` (UUID, primary key), `email` (varchar, unique, not null), `password_hash` (varchar, not null), `created_at` (timestamp), and `updated_at` (timestamp). Use a database migration tool like Alembic or Flyway to manage the schema.",
            "status": "pending",
            "testStrategy": "Run the migration and verify its successful application. Manually inspect the database schema to confirm all columns, types, and constraints (unique, not null) are correctly created. Write a rollback test for the migration."
          },
          {
            "id": 2,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., `POST /api/v1/register`) that allows new users to create an account.",
            "dependencies": [],
            "details": "The endpoint should accept an email and password. It must validate the input (e.g., password strength, valid email format), check if the email is already in use, hash the password using bcrypt, and store the new user in the database. On success, return a 201 Created status with the new user's ID and email.",
            "status": "pending",
            "testStrategy": "Write unit tests for input validation logic. Write integration tests to cover successful registration, registration with a duplicate email, and registration with invalid data (e.g., weak password, bad email format). Verify the password stored in the database is properly hashed."
          },
          {
            "id": 3,
            "title": "Implement User Login Endpoint and JWT Generation",
            "description": "Create an API endpoint (e.g., `POST /api/v1/login`) for users to authenticate and receive a JSON Web Token (JWT).",
            "dependencies": [],
            "details": "The endpoint accepts an email and password. It will retrieve the user by email, compare the provided password against the stored hash using bcrypt. If valid, generate a signed JWT containing the user ID and an expiration claim (e.g., 1 hour). Return the JWT in the response body.",
            "status": "pending",
            "testStrategy": "Write integration tests for successful login with correct credentials, failed login with an incorrect password, and failed login for a non-existent user. Unit test the JWT generation and verify the token payload and signature."
          },
          {
            "id": 4,
            "title": "Create Authentication Middleware for Protected Routes",
            "description": "Implement middleware to verify the JWT on incoming requests to secure specific API endpoints, making user information available to the request handler.",
            "dependencies": [],
            "details": "The middleware should extract the JWT from the `Authorization: Bearer <token>` header. It must validate the token's signature and check for expiration. If valid, decode the token, retrieve the user from the database, and attach the user object to the request context. If the token is invalid, expired, or missing, return a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Create a sample protected endpoint. Write integration tests that attempt to access it with a valid token, an expired token, a malformed token, and no token. Assert that the correct HTTP status code and response body are returned for each case."
          }
        ]
      },
      {
        "id": 75,
        "title": "Implement Global Search UI",
        "description": "Add a global search bar to the application's header or main page. As the user types, it should call the `/api/search` endpoint and display the results, including session titles, similarity scores, and snippets.",
        "details": "The search results page should clearly present the findings. Each result should be a link to the corresponding session page (`/sessions/[id]`). The UI should also display the 'fallback' indicator if the API returns it.",
        "testStrategy": "Use the UI to search for a term. Verify that results are displayed and that clicking a result navigates to the correct session. Test the keyword fallback by searching for a term when the embeddings service is known to be down and check for the UI indicator.",
        "priority": "low",
        "dependencies": [
          74
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the necessary database table(s) to store user information, including credentials and profile data.",
            "dependencies": [],
            "details": "Create a 'users' table with columns: 'id' (primary key, auto-increment), 'email' (unique, string), 'password_hash' (string), 'created_at' (timestamp), and 'updated_at' (timestamp). Use a database migration tool to manage schema changes.",
            "status": "pending",
            "testStrategy": "Verify the migration runs successfully against a test database. Manually inspect the schema to confirm all columns, types, and constraints (e.g., 'unique') are created correctly. Write a unit test to ensure the User model can be instantiated."
          },
          {
            "id": 2,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a public API endpoint for new users to register for an account by providing their credentials.",
            "dependencies": [],
            "details": "Implement a `POST /api/auth/register` endpoint. It should accept 'email' and 'password'. Perform validation: check for empty fields, valid email format, and if the email already exists. Hash the password using a strong algorithm like bcrypt before storing it. On success, return a 201 status code and the newly created user object (excluding the password hash).",
            "status": "pending",
            "testStrategy": "Write integration tests to cover: successful registration, attempting to register with a duplicate email, registration with invalid input (e.g., malformed email, weak password), and ensuring the password stored in the database is properly hashed and not plaintext."
          },
          {
            "id": 3,
            "title": "Implement User Login API Endpoint and Token Generation",
            "description": "Create an API endpoint for users to log in. Upon successful authentication, generate and return a session token (JWT).",
            "dependencies": [],
            "details": "Implement a `POST /api/auth/login` endpoint. It should accept 'email' and 'password'. Find the user by email. Compare the provided password with the stored hash. If credentials are valid, generate a JSON Web Token (JWT) containing the user ID and an expiration date. Return the JWT to the client.",
            "status": "pending",
            "testStrategy": "Write integration tests for: successful login with correct credentials, failed login with an incorrect password, and failed login with a non-existent email. Verify that a valid JWT with the correct payload (user ID, expiration) is returned on success."
          },
          {
            "id": 4,
            "title": "Create Authentication Middleware for Protected Routes",
            "description": "Develop middleware to secure API endpoints, ensuring they are only accessible by users with a valid session token.",
            "dependencies": [],
            "details": "Create a middleware function that intercepts requests. It should extract the JWT from the 'Authorization: Bearer <token>' header. It must verify the token's signature and check for expiration. If the token is valid, decode the payload to identify the user and attach the user's information to the request object for use in subsequent handlers. If the token is missing or invalid, return a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Create a sample protected endpoint. Write integration tests to verify that: a request with a valid token is allowed, a request without a token is rejected with a 401 error, and a request with an invalid or expired token is rejected with a 401 error."
          }
        ]
      },
      {
        "id": 76,
        "title": "UI/UX Polish and Accessibility Enhancements",
        "description": "Review and enhance all new UI components (Chat, Summary, Search) for accessibility and user experience. Implement full keyboard navigation, ARIA labels, and clear empty/loading states.",
        "details": "This includes adding ARIA live regions for streaming chat, ensuring focus management when opening panels, and providing high-contrast mode compliance. Add clear empty states for when a session has no summary or search returns no results. Also, handle the case where the local Nexa server is offline.",
        "testStrategy": "Perform an accessibility audit using browser developer tools (e.g., Lighthouse) and a screen reader. Navigate the entire application using only the keyboard. Manually test empty and error states by stopping the backend server or clearing data.",
        "priority": "low",
        "dependencies": [
          69,
          72,
          75
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the necessary database table(s) to store user information, including credentials and profile data.",
            "dependencies": [],
            "details": "Define a 'users' table with columns for id (primary key, UUID), email (unique, text), hashed_password (text), created_at (timestamp), and updated_at (timestamp). Use a database migration tool like Alembic or Flyway to script and apply the schema changes.",
            "status": "pending",
            "testStrategy": "Write a migration test to apply and revert the schema change. Manually inspect the database schema after migration to confirm all columns, types, and constraints (e.g., unique index on email) are correctly created."
          },
          {
            "id": 2,
            "title": "Implement Password Hashing and Verification Service",
            "description": "Create a secure, isolated service for hashing new user passwords and verifying passwords during login attempts.",
            "dependencies": [],
            "details": "Use a strong, adaptive hashing algorithm like Argon2id or bcrypt. Create two core functions: `hashPassword(plainTextPassword)` which returns a hash string, and `verifyPassword(plainTextPassword, storedHash)` which returns a boolean. This logic should be in a dedicated 'security' or 'crypto' module.",
            "status": "pending",
            "testStrategy": "Write unit tests for the service. Test that `hashPassword` always produces a different hash for the same input. Test that `verifyPassword` returns true for a correct password and false for an incorrect one. Ensure it handles edge cases like empty passwords."
          },
          {
            "id": 3,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a backend API endpoint (e.g., POST /api/v1/auth/register) to handle new user sign-ups.",
            "dependencies": [],
            "details": "The endpoint must accept user data (email, password). It should validate the input (e.g., valid email format, password complexity), check if the email already exists in the 'users' table, hash the password using the service from subtask 2, and store the new user record. Return a 201 Created status on success or appropriate 4xx error codes.",
            "status": "pending",
            "testStrategy": "Write API integration tests. Test the happy path for successful registration. Test failure cases: duplicate email, invalid email format, weak password, missing fields. Verify that the password stored in the database is a valid hash and not plaintext."
          },
          {
            "id": 4,
            "title": "Develop User Login API Endpoint and JWT Issuance",
            "description": "Create a backend API endpoint (e.g., POST /api/v1/auth/login) to authenticate users and issue a JSON Web Token (JWT).",
            "dependencies": [],
            "details": "The endpoint accepts an email and password. It will fetch the user from the database by email, use the password service (subtask 2) to verify the password. If valid, generate a signed JWT containing the user ID and an expiration claim. The JWT secret key must be loaded from environment variables, not hardcoded.",
            "status": "pending",
            "testStrategy": "Write API integration tests. Test successful login and verify the structure and signature of the returned JWT. Test failed login attempts with an incorrect password and a non-existent email. Test that the JWT payload contains the correct user ID and expiry."
          },
          {
            "id": 5,
            "title": "Implement Middleware for Protecting Authenticated Routes",
            "description": "Create server-side middleware to verify the JWT on incoming requests to protected API endpoints.",
            "dependencies": [],
            "details": "The middleware should extract the JWT from the 'Authorization' header (Bearer scheme). It will then validate the token's signature and expiration. If valid, it should decode the payload, retrieve the user ID, and attach the user object or ID to the request context for use in downstream handlers. If the token is invalid or missing, it must return a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Write integration tests for a sample protected endpoint. Test that a request with a valid JWT is allowed. Test that requests with no token, an expired token, an invalid signature, or a malformed token are all rejected with a 401 status code."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-08T17:44:30.733Z",
      "updated": "2025-09-23T19:49:05.109Z",
      "description": "Tasks for master context"
    }
  }
}